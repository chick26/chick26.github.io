<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[VueLearningDay03]]></title>
    <url>%2F2020%2F08%2F17%2FVueLearningDay03%2F</url>
    <content type="text"><![CDATA[基础语法事件监听 v-on介绍 作用：绑定事件监听器 缩写：@ 预期：Function | Inline Statement | Object 参数：event v-on 参数 当通过methods中定义方法，以供@click调用时，需要注意参数问题： 情况一：如果该方法不需要额外参数，那么方法后的()可以不添加。但是注意：如果方法本身中有一个参数，那么会默认将原生事件event参数传递进去 情况二：如果需要同时传入某个参数，同时需要event时，可以通过$event传入事件。12345678&lt;body&gt; &lt;button @click="btnClick('abc', $event)"&gt;&lt;/button&gt;&lt;/body&gt;&lt;script&gt; btnClick(a,event)&#123; console.log('----', a, event); &#125;&lt;/script&gt; v-on 修饰符 在某些情况下，我们拿到event的目的可能是进行一些事件处理。 Vue提供了修饰符来帮助我们方便的处理一些事件： .stop - 调用 event.stopPropagation()。 .prevent - 调用 event.preventDefault()。 .{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调。 .native - 监听组件根元素的原生事件。 .once - 只触发一次回调。123456789101112131415&lt;!-- v-on 修饰符 --&gt;&lt;!-- 阻止事件冒泡 --&gt;&lt;button @click.stop="doThis"&gt;&lt;/button&gt;&lt;!--组织默认行为 --&gt;&lt;button @click.prevent="doThis"&gt;&lt;/button&gt;&lt;!-- 阻止默认行为，没有表达式 --&gt;&lt;form @click.stop="doThis"&gt;&lt;/form&gt;&lt;!-- 串联修饰符 --&gt;&lt;button @click.stop.prevent="doThis"&gt;&lt;/button&gt;&lt;!-- 键修饰符，键别名 --&gt;&lt;input @keyup.enter='onEnter'&gt;&lt;!-- 键修饰符，键代码 --&gt;&lt;input @keyup.13='onEnter'&gt;&lt;!-- 点击回调只会触发一次 --&gt;&lt;button @click.once="doThis"&gt;&lt;/button&gt; 条件判断 v-if、v-else-if、v-else 这三个指令与JavaScript的条件语句if、else、else if类似。Vue的条件指令可以根据表达式的值在DOM中渲染或销毁元素或组件简单的案例演示： v-if的原理： v-if后面的条件为false时，对应的元素以及其子元素不会渲染。也就是根本没有不会有对应的标签出现在DOM中。123456789101112131415&lt;body&gt; &lt;div id="app"&gt; &lt;h1 v-if="isShow"&gt;TRUE&lt;/h1&gt; &lt;h2 v-else&gt;FALSE&lt;/h2&gt; &lt;/div&gt; &lt;script src="./js/vue.js"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', //挂载需要管理的元素 data: &#123; //定义元素包含的数据 isShow: true &#125; &#125;) &lt;/script&gt;&lt;/body&gt; v-else-if 12345678910111213141516171819202122232425262728293031323334 &lt;!-- else if --&gt; &lt;h2 v-if="score&gt;90"&gt;优秀&lt;/h2&gt; &lt;h2 v-else-if="score&gt;80"&gt;良好&lt;/h2&gt; &lt;h2 v-else&gt;不好&lt;/h2&gt;``` * 用户登录切换案例```html&lt;body&gt;&lt;div id="app"&gt; &lt;span v-if="isUser" &gt; &lt;label for="username"&gt;用户账号&lt;/label&gt; &lt;input type="text" id="username" placeholder="用户账号"&gt; &lt;/span&gt; &lt;span v-else&gt; &lt;label for="email"&gt;用户邮箱&lt;/label&gt; &lt;input type="text" id="email" placeholder="用户邮箱"&gt; &lt;/span&gt; &lt;button @click="isUser = !isUser"&gt;切换类型&lt;/button&gt;&lt;/div&gt;&lt;script src="./js/vue.js"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; isUser: true &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 存在问题:如果我们在有输入内容的情况下，切换了类型，我们会发现文字依然显示之前的输入的内容。但是按道理讲，我们应该切换到另外一个input元素中了。在另一个input元素中，我们并没有输入内容。为什么会出现这个问题呢？ 问题解答:这是因为Vue在进行DOM渲染时，出于性能考虑，会尽可能的复用已经存在的元素，而不是重新创建新的元素。在上面的案例中，Vue内部会发现原来的input元素不再使用，直接作为else中的input来使用了。 解决方案：如果我们不希望Vue出现类似重复利用的问题，可以给对应的input添加key并且我们需要保证key的不同12345678910111213141516171819202122232425262728293031323334353637383940&lt;body&gt;&lt;div id="app"&gt; &lt;span v-if="isUser" &gt; &lt;label for="username"&gt;用户账号&lt;/label&gt; &lt;input type="text" id="username" placeholder="用户账号"&gt; &lt;/span&gt; &lt;span v-else&gt; &lt;label for="email"&gt;用户邮箱&lt;/label&gt; &lt;input type="text" id="email" placeholder="用户邮箱"&gt; &lt;/span&gt; &lt;button @click="isUser = !isUser"&gt;切换类型&lt;/button&gt; &lt;span v-if="isUser" &gt; &lt;label for="username"&gt;用户账号&lt;/label&gt; &lt;!-- key 作为标识决定是否复用 --&gt; &lt;input type="text" id="username" placeholder="用户账号" key="usernameinput"&gt; &lt;/span&gt; &lt;span v-else&gt; &lt;label for="email"&gt;用户邮箱&lt;/label&gt; &lt;input type="text" id="email" placeholder="用户邮箱" key="emailinput"&gt; &lt;/span&gt; &lt;button @click="isUser = !isUser"&gt;切换类型&lt;/button&gt;&lt;/div&gt;&lt;script src="./js/vue.js"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; isUser: true &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; v-show v-show 的用法和 v-if 非常相似，也用于决定一个元素是否渲染： v-if 当条件为 false 时，压根不会有对应的元素在 DOM 中。 v-show 当条件为 false 时，仅仅是将元素的 display 属性设置为 none 而已。 开发中如何选择呢？ 当需要在显示与隐藏之间切片很频繁时，使用 v-show 当只有一次切换时，通过使用 v-if v-for 当我们有一组数据需要进行渲染时，我们就可以使用v-for来完成。v-for的语法类似于JavaScript中的for循环。格式如下：item in items的形式。 我们来看一个简单的案例：如果在遍历的过程中不需要使用索引值v-for=”movie in movies”依次从movies中取出movie，并且在元素的内容中，我们可以使用Mustache语法，来使用movie。如果在遍历的过程中，我们需要拿到元素在数组中的索引值呢？语法格式：v-for=(item, index) in items其中的index就代表了取出的item在原数组的索引值。 key 属性 官方推荐我们在使用v-for时，给对应的元素或组件添加上一个:key属性。为什么需要这个key属性呢（了解）？ 这个其实和Vue的虚拟DOM的Diff算法有关系。 我们希望可以在B和C之间加一个F，Diff算法默认执行起来是这样的。即把C更新成F，D更新成C，E更新成D，最后再插入E，是不是很没有效率？所以我们需要使用key来给每个节点做一个唯一标识Diff算法就可以正确的识别此节点找到正确的位置区插入新的节点。 所以一句话，key的作用主要是为了高效的更新虚拟DOM。123456789101112131415161718192021222324252627&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 遍历中未使用索引值 --&gt; &lt;ul&gt; &lt;li v-for="item in names"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;!-- 遍历获取索引值 --&gt; &lt;ul&gt; &lt;li v-for="(item, index) in names" :key="item"&gt;&#123;&#123;index&#125;&#125;.&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;!-- 获取 value 和 key --&gt; &lt;!-- &lt;ul&gt; --&gt; &lt;!-- &lt;li v-for="(value, key) in names"&gt;&lt;/li&gt; --&gt; &lt;!-- &lt;/ul&gt; --&gt; &lt;/div&gt; &lt;script src="./js/vue.js"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', //挂载需要管理的元素 data: &#123; //定义元素包含的数据 names: ['why', 'how', 'james', 'curry'] &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 检测数组更新 数据是响应式的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;body&gt; &lt;div id="app"&gt; &lt;ul&gt; &lt;li v-for="letter in letters"&gt;&#123;&#123;letter&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;button @click="btnclick"&gt;Button&lt;/button&gt; &lt;/div&gt; &lt;script src="./js/vue.js"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; letters: ['a','b','c','d'] &#125;, methods: &#123; btnclick()&#123; //1.push //this.letters.push('aaa') //2.通过索引值修改数组元素 // this.letters[0] // 3.pop() 删除数组最后一个元素 // this.letters.pop(); // 4.shift() 删除数组第一个元素 // this.letters.shift(); // 5.unshift() 在数组前增加元素 // this.letters.unshift(); // 6.splice 删除元素/插入元素/替换元素 //删除元素(start, 删除元素数(不传，后面全部删除)， ) //替换元素(start, 替换元素数, 替换元素) //插入元素(start, 0, 增加元素) // this.letters.splice() // 7.sort() // this.letters.sort() // 8.反转 reverse() //this.letters.reverse() //注意，通过索引值修改数组元素不会改变 // this.letters[0] = 'bbbb'; // this.letters.splice(0,1,'bbbb') // set(要修改的对象，索引值，修改后的值) Vue.set(this.letters,0,'bbbbb') &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;]]></content>
      <tags>
        <tag>Html</tag>
        <tag>VUE</tag>
        <tag>Day03</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueLearningDay02]]></title>
    <url>%2F2020%2F08%2F13%2FVueLearningDay02%2F</url>
    <content type="text"><![CDATA[ES6let / var 块级作用域 ES5之前 if 和 for 没有作用域的概念，都需要借助 function 的作用域限制 JS中使用var来声明一个变量时, 变量的作用域主要是和函数的定义有关 针对于其他块定义来说是没有作用域的，比如if/for等，这在我们开发中往往会引起一些问题const 在很多语言中已经存在, 比如C/C++中, 主要的作用是将某个变量修饰为常量. 在JavaScript中也是如此, 使用const修饰的标识符为常量, 不可以再次赋值. 什么时候使用const呢? 当我们修饰的标识符不会被再次赋值时, 就可以使用const来保证数据的安全性. 建议: 在ES6开发中,优先使用const, 只有需要改变某一个标识符的时候才使用let. 注意： const 定义时必须先进行赋值 常量的含义时对象不能改变，但是对象的属性可以修改增强写法123456789101112131415161718192021222324252627282930313233//1.属性增强写法const name = 'why';const age = 18;//ES6 前的写法const obj=&#123; name = name, age = age&#125;//ES6 的写法const obj=&#123; name, age&#125;//2.函数的增强写法//ES5const obj=&#123; run: function()&#123; &#125;, eat: function()&#123; &#125;&#125;//ES6const obj=&#123; run()&#123; &#125;, eat()&#123; &#125;&#125;]]></content>
      <tags>
        <tag>Html</tag>
        <tag>VUE</tag>
        <tag>Day02</tag>
        <tag>ES 6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueLearningDay01]]></title>
    <url>%2F2020%2F08%2F12%2FVueLearningDay01%2F</url>
    <content type="text"><![CDATA[Day One 大纲一、邂逅Vue 认识 Vue.js 为什么学习Vue Vue的渐进式 Vue的特点 安装Vue CDN引入 下载引入 npm安装 Vue使用 mustache - Vue响应式 Vue列表展示 - v-for Vue计数器 - 事件监听 Vue的MVVM Vue的Option el \ data \ methods 生命周期函数 二、插值语法 mustache语法 v-once 只能改变一次 v-html 根据html语法显示 v-text v-pre 原生展示mustache v-cloak三、动态绑定 v-bind v-bind 绑定基本属性 v-bind：src v-bind：href v-bind 动态绑定 class 对象语法 Practice01 数组语法 v-bind 动态绑定 style 对象语法 数组语法四、计算属性 案例一： fullname 案例二： totalprice 案例三： setter &amp; getter Vue.jsVue.js安装 方法一直接CND引入 1234&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue"&gt;&lt;/script&gt; 方式二下载和引入 12&lt;!-- 开发环境 --&gt; https://vuejs.org/js/vue.js&lt;!-- 生产环境 --&gt; https://vuejs.org/js/vue.min.js 方法三后续通过webpack和CIL的使用 初识Vue实例123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--定义一个元素--&gt; &lt;div id="app"&gt;&#123;&#123;messgae&#125;&#125;&lt;/div&gt; &lt;!--本地加载Vuejs--&gt; &lt;script src="./js/vue.js"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', //挂载需要管理的元素 data: &#123; //定义对象包含的数据 message:'Hello VUE' &#125; &#125;) &lt;/script&gt; &lt;!--使用JavaScript实现--&gt; &lt;script type="text/javascript" language="javascript"&gt;&lt;/script&gt; &lt;script&gt; document.write("&lt;div&gt;Hello world&lt;/div&gt;") &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Vue框架【声明式编程-内部存在命令】 创建Vue对象 挂载需要管理的元素 [el] 定义相关的数据等信息 [data] 这些数据可以是我们直接定义出来的，比如像上面这样。 也可能是来自网络，从服务器加载的。 JS流程【命令式编程】 创建元素，设置元素属性 定义message变量 将message变量放到div中显示 列表展示12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;列表展示&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;ul&gt; &lt;li v-for="item in movies"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script src="./js/vue.js"&gt; &lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', data:&#123; message:'Movie', movies:['SuperMan','SpiderMan','BatMan','IronMan'] &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; v-for指令，响应式完成 计数器123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;计数器&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;h2&gt;当前计数: &#123;&#123;counter&#125;&#125;&lt;/h2&gt; &lt;!-- &lt;button v-on:click="counter++"&gt;+&lt;/button&gt; --&gt; &lt;!-- &lt;button v-on:click="counter--"&gt;-&lt;/button&gt; --&gt; &lt;button v-on:click="add"&gt;+&lt;/button&gt; &lt;button v-on:click="sub"&gt;-&lt;/button&gt; &lt;/div&gt; &lt;script src='./js/vue.js'&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', data:&#123; counter: 0 &#125;, methods:&#123; add: function()&#123; this.counter++; console.log('加1') &#125;, sub: function()&#123; this.counter--; console.log('减1') &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 新的属性：methods，该属性用于在Vue对象中定义方法。 新的指令：v-on:click(@click)—语法糖, 该指令用于监听某个元素的点击事件，并且需要指定当发生点击时，执行的方法(方法通常是methods中定义的方法) Vue中的MVVM MVVM（Model-View-ViewModel）是对 MVC（Model-View-Control）和 MVP（Model-View-Presenter）的进一步改进。 『View』：视图层（UI 用户界面） 『ViewModel』：业务逻辑层（一切 js 可视为业务逻辑） 『Model』：数据层（存储数据及对数据的处理如增删改查） MVVM 将数据双向绑定（data-binding）作为核心思想，View 和 Model 之间没有联系，它们通过 ViewModel 这个桥梁进行交互。 Model 和 ViewModel 之间的交互是双向的，因此 View 的变化会自动同步到 Model，而 Model 的变化也会立即反映到 View 上显示。 当用户操作 View，ViewModel 感知到变化，然后通知 Model 发生相应改变；反之当 Model 发生改变，ViewModel 也能感知到变化，使 View 作出相应更新。。 计数器中的MVVM View依然是我们的DOM Model就是我们我们抽离出来的obj ViewModel就是我们创建的Vue对象实例MVVM工作原理 ViewModel通过Data Binding让obj中的数据实时的在DOM中显示。 ViewModel通过DOM Listener来监听DOM事件，并且通过methods中的操作，来改变obj中的数据。 Vue示例 Options el: 类型：string | HTMLElement 作用：决定之后Vue实例会管理哪一个DOM。 data: 类型：Object | Function （组件当中data必须是一个函数） 作用：Vue实例对应的数据对象。 methods: 类型：{ [key: string]: Function } 作用：定义属于Vue的一些方法，可以在其他地方调用，也可以在指令中使用。 title: VueLearningDay02date: 2020-08-13 08:17:02tags: VUE Html Day02 模板语法插值操作Mustache数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值：1&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt; v-once能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定：1&lt;span v-once&gt;这个将不会改变: &#123;&#123; msg &#125;&#125;&lt;/span&gt; v-html能解析html语句，输出实际展示内容1&lt;span v-html="msg"&gt;&lt;/span&gt; v-pre不解析指令，直接显示元素1&lt;span v-pre &gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt; v-cloak减少需要长时间加载的元素源码暴露的风险,实际开发中函数会被解析为虚拟DOM，无太大影响：1234567891011121314151617181920212223242526&lt;head&gt;...... &lt;!-- 遇到有v-cloak属性的元素，在js指令执行前不展示 --&gt; &lt;style&gt; [v-cloak]&#123; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- v-cloak --&gt; &lt;h1 v-cloak&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;script src="./js/vue.js"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', //挂载需要管理的元素 data: &#123; //定义元素包含的数据 message: 'Hello VUE' &#125; &#125;) &lt;/script&gt; &lt;script src="./js/vue.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 动态绑定v-bind 作用：动态绑定属性 缩写：: 预期：any (with argument) | Object (without argument) 参数：attrOrProp (optional) Mustache只在内容里面会使用，属性需要v-bind 动态绑定class对象语法12345678910111213&lt;!-- 用法一：直接通过&#123;&#125;绑定一个类 --&gt;&lt;h2 :class="&#123;'active': isActive&#125;"&gt;Hello World&lt;/h2&gt;&lt;!-- 用法二：也可以通过判断，传入多个值 --&gt;&lt;h2 :class="&#123;'active': isActive, 'line': isLine&#125;"&gt;Hello World&lt;/h2&gt;&lt;!-- 用法三：和普通的类同时存在，并不冲突 --&gt;&lt;!-- 注：如果isActive和isLine都为true，那么会有title/active/line三个类 --&gt;&lt;h2 class="title" :class="&#123;'active': isActive, 'line': isLine&#125;"&gt;Hello World&lt;/h2&gt;&lt;!-- 用法四：如果过于复杂，可以放在一个methods或者computed中 --&gt;&lt;!-- 注：classes是一个计算属性 --&gt;&lt;h2 class="title" :class="classes"&gt;Hello World&lt;/h2&gt; 数组语法12345678910111213&lt;!-- 用法一：直接通过&#123;&#125;绑定一个类 --&gt;&lt;h2 :class="['active']"&gt;Hello World&lt;/h2&gt;&lt;!-- 用法二：也可以传入多个值 --&gt;&lt;h2 :class=“[‘active’, 'line']"&gt;Hello World&lt;/h2&gt;&lt;!-- 用法三：和普通的类同时存在，并不冲突 --&gt;&lt;!-- 注：会有title/active/line三个类 --&gt;&lt;h2 class="title" :class=“[‘active’, 'line']"&gt;Hello World&lt;/h2&gt;&lt;!-- 用法四：如果过于复杂，可以放在一个methods或者computed中 --&gt;&lt;!-- 注：classes是一个计算属性 --&gt;&lt;h2 class="title" :class="classes"&gt;Hello World&lt;/h2&gt; 动态绑定Style对象语法123456&lt;!-- 对象语法 --&gt; &lt;p&gt;绑定Style&lt;/p&gt;&lt;!-- &lt;h2 :style="&#123;key（属性名）： value（属性值）&#125;"&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; --&gt; &lt;h2 :style="&#123;FontSize: finalSize + 'px', color: finalColor&#125;"&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;&lt;!-- 数组语法 --&gt; &lt;h2 :style="[baseStyle, baseStyle1]"&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; 计算属性 对比方法 methods，computed 具有缓存，更高效 简单操作 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;计算属性&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 常规显示 --&gt; &lt;h2&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; &lt;/h2&gt; &lt;!-- 方法显示 --&gt; &lt;h2&gt;&#123;&#123;GetFullName()&#125;&#125;&lt;/h2&gt; &lt;!-- 计算属性 --&gt; &lt;h2&gt;&#123;&#123;FullName&#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;script src="./js/vue.js"&gt; &lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', data:&#123; firstName: 'Lerbon', lastName: 'James' &#125;, methods:&#123; GetFullName()&#123; return this.firstName + ' ' + this.lastName &#125; &#125;, computed:&#123; FullName: function()&#123; return this.firstName + ' ' + this.lastName &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 复杂操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;计算属性&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 复杂操作 显示书总价--&gt; &lt;h2&gt;总价格：&#123;&#123;TotalPrice&#125;&#125; &lt;/h2&gt; &lt;/div&gt; &lt;script src="./js/vue.js"&gt; &lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', data:&#123; books: [ &#123;id: 110, name: '红楼梦', price: 119&#125;, &#123;id: 111, name: '三国演义', price: 100&#125;, &#123;id: 112, name: '西游记', price: 19&#125;, &#123;id: 113, name: '水浒传', price: 29&#125;, ] &#125;, methods:&#123; GetFullName()&#123; return this.firstName + ' ' + this.lastName &#125; &#125;, computed:&#123; //filter\map\reduce TotalPrice: function()&#123; let result = 0 for (let i=0; i &lt; this.books.length; i++)&#123; result += this.books[i].price &#125; return result // for (let i in this.books)&#123; // this.book[i] // &#125; // for (let book of this.books)&#123; // &#125; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 完整写法 每个计算属性都包含一个getter和一个setter 在上面的例子中，我们只是使用getter来读取。 在某些情况下，你也可以提供一个setter方法（不常用）。 在需要写setter的时候，代码如下：1234567891011FullName_Whole: &#123; set: function(newValue)&#123; // console.log('-----', newValue) const names = newValue.split(' '); this.firstName = names[0]; this.lastName = names[1]; &#125;, get: function()&#123; return this.firstName + ' ' + this.lastName &#125;&#125; 计算属性与方法的对比 计算属性会有缓存，只计算一次 方法每次都要进行调用，会多次计算]]></content>
      <tags>
        <tag>Html</tag>
        <tag>VUE</tag>
        <tag>Day01</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Html Function]]></title>
    <url>%2F2020%2F08%2F05%2FHtml-Function%2F</url>
    <content type="text"><![CDATA[HTML 元素 开始标签 元素内容 结束标签 &#60;html&gt; 定义整个 HTML 文档 \&lt;/html&gt; &#60;body&gt; 定义 HTML 文档的主体 \&lt;/body&gt; &#60;h x&gt; 第x个标题 \&lt;/h x&gt; &#60;p&gt; 定义 HTML 文档中的一个段落 \&lt;/p&gt; &#60;br /&gt; 换行 无 &#60;!— xxx —&gt; 标记注释 无 &#60;a href=”default.htm” &gt; 定义Html链接 \&lt;/a&gt; &#60;img src=”” width=”” height=”” /&gt; 定义Html图像 无 HTML 属性详情参考使用手册 属性 值 描述 class classname 规定元素的类名（classname） id id 规定元素的唯一 id style style_definition 规定元素的行内样式（inline style) title text 规定元素的额外信息（可在工具提示中显示） 注： 属性值应该始终被包括在引号内。双引号是最常用的，不过使用单引号也没有问题。 在某些个别的情况下，比如属性值本身就含有双引号，那么您必须使用单引号，例如：1name='Bill "HelloWorld" Gates' 文本格式化文字格式化标签 标签 描述 &#60;b&gt; 定义粗体文本 &#60;big&gt; 定义大号字 &#60;em&gt; 定义着重文字 &#60;i&gt; 定义斜体字 &#60;small&gt; 定义小号字 &#60;strong&gt; 定义加重语气 &#60;sub&gt; 定义下标字 &#60;sup&gt; 定义上标字 &#60;ins&gt; 定义插入字 &#60;del&gt; 定义删除字 “计算机”输出标签 标签 描述 &#60;code&gt; 定义计算机代码 &#60;kbd&gt; 定义键盘码 &#60;samp&gt; 定义计算机代码样本 &#60;tt&gt; 定义打字机代码 &#60;var&gt; 定义变量 &#60;pre&gt; 定义预格式文本 引用、引用和术语定义 标签 描述 &#60;abbr&gt; 定义缩写 &#60;acronym&gt; 定义首字母缩写 &#60;address&gt; 定义地址 &#60;bdo&gt; 定义文字方向 &#60;blockquote&gt; 定义长的引用 &#60;q&gt; 定义短的引用语 &#60;cite&gt; 定义引用、引证 &#60;dfn&gt; 定义一个定义项目 HTML5 语义元素 标签 描述 header 定义文档或节的页眉 nav 定义导航链接的容器 section 定义文档中的节 article 定义独立的自包含文章 aside 定义内容之外的内容（比如侧栏) footer 定义文档或节的页脚 details 定义额外的细节 summary 定义 details 元素的标题]]></content>
      <tags>
        <tag>Html</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Html Introduction]]></title>
    <url>%2F2020%2F08%2F05%2FHtml-Learning%2F</url>
    <content type="text"><![CDATA[什么是 HTML？HTML 是用来描述网页的一种语言 HTML 指的是超文本标记语言 (Hyper Text Markup Language)HTML 不是一种编程语言，而是一种标记语言 (markup language)标记语言是一套标记标签 (markup tag)HTML 使用标记标签来描述网页 HTML 标签HTML 标记标签通常被称为 HTML 标签 (HTML tag) HTML 标签是由尖括号包围的关键词，比如 \ HTML 标签通常是成对出现的，比如 \ 和 \&lt;\b&gt; 标签对中的第一个标签是开始标签，第二个标签是结束标签开始和结束标签也被称为开放标签和闭合标签 HTML 文档 = 网页HTML 文档描述网页HTML 文档包含 HTML 标签和纯文本HTML 文档也被称为网页 代码示例123456789&lt;html&gt;&lt;body&gt;&lt;h1&gt;我的第一个标题&lt;/h1&gt;&lt;p&gt;我的第一个段落。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 例子解释\ 与 \ 之间的文本描述网页\ 与 \ 之间的文本是可见的页面内容\ 与 \ 之间的文本被显示为标题\ 与 \ 之间的文本被显示为段落]]></content>
      <tags>
        <tag>Html</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Regression]]></title>
    <url>%2F2020%2F03%2F04%2FRegression%2F</url>
    <content type="text"><![CDATA[Regression回归，即找到一个函数(Function)，通过输入特征 x，输出一个数值(Scalar) 模型步骤 Step 1 模型假设，选择模型框架 假设： Linear Model $y=b+\sum w_ix_i$]]></content>
      <tags>
        <tag>Mechine Learning</tag>
        <tag>Regression</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaFundation]]></title>
    <url>%2F2020%2F01%2F07%2FJavaFundation%2F</url>
    <content type="text"><![CDATA[1.面向过程和面向对象面向对象： 面向对象易维护、易复用、易扩展。 面向过程： asd]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-Numpy]]></title>
    <url>%2F2019%2F11%2F04%2FPython-Numpy%2F</url>
    <content type="text"></content>
      <tags>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DataMining with KNN]]></title>
    <url>%2F2019%2F09%2F28%2FDataMining-with-KNN%2F</url>
    <content type="text"><![CDATA[K-NN算法 优点： 精度高，对异常值不敏感，无数据输入假定 缺点： 计算复杂度高 st=>start: 开始语句 in=>inputoutput: 输入值 e=>end: 结束语句 op=>operation: 执行操作 cond=>condition: 是否成立？ out=>inputoutput: 输出值 st->in->op->cond cond(yes)->out cond(no)->op out->e{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <tags>
        <tag>DataMining</tag>
        <tag>KNN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Learning Plan]]></title>
    <url>%2F2019%2F08%2F20%2FLearning-Plan%2F</url>
    <content type="text"><![CDATA[Main Line 理论基础 算法分析与设计 Mooc 概率论 微积分 Big Picture of Calculus; blibili 线性代数 Mit Linear Algebra; 网易公开课 凸优化理论 机器学习 西瓜书 机器学习，周志华; 部分公式推导,南瓜书 更详细的理论 统计学习方法; 代码实现 实战应用 机器学习实战 网络课程 吴恩达; 李宏毅 深度应用 TensorFlow 计算机视觉 斯坦福; 笔记 自然语言处理 斯坦福; 笔记]]></content>
      <tags>
        <tag>Mechine Learning</tag>
        <tag>Material</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Setting]]></title>
    <url>%2F2019%2F08%2F15%2FHexo-Setting%2F</url>
    <content type="text"><![CDATA[利用gitpage托管hexo博客 基本步骤 创建github账号，创建以用户名为为命名的仓库，如: chick26.github.io,此为固定写法 安装Git， 初始化Git，利用SSH完成推送 安装Node.js 安装 Hexo , 完成初次推送 域名绑定(无资金) 更换主题(NexT) 设置页面 增加leancloud支持 你的第一篇博文 Markdown公式渲染 初始化Git打开git Bash，设置基本配置信息12git config --global user.name "你的GitHub用户名"git config --global user.email "你的GitHub注册邮箱" 生成SSH密钥文件1ssh-keygen -t rsa -C "你的GitHub注册邮箱" 将位于 .ssh// 的 id_rsa.pub 密钥文件复制到 GitHub 设置中的SSH Key中在git Bash中输入指令以检测是否完成关联：1ssh git@github.com 如上则说明成功。这里之所以设置GitHub密钥原因是，通过非对称加密的公钥与私钥来完成加密，公钥放置在GitHub上，私钥放置在自己的电脑里。GitHub要求每次推送代码都是合法用户，所以每次推送都需要输入账号密码验证推送用户是否是合法用户，为了省去每次输入密码的步骤，采用了ssh，当你推送的时候，git就会匹配你的私钥跟GitHub上面的公钥是否是配对的，若是匹配就认为你是合法用户，则允许推送。这样可以保证每次的推送都是正确合法的。 安装Node.jsHexo基于Node.js开发。安装Node.js会包含环境变量及npm的安装，安装后，检测Node.js以及npm是否安装成功。12node -vnpm -v 安装Hexo新建一个专门保存博客资源的文件夹1cd myBlog 在文件夹中打开git Bash，利用npm安装Hexo1npm install -g hexo-cli 安装完成后，初始化博客1hexo init blog 关联与推送推送网站，也就是发布网站，让我们的网站可以被更多的人访问。在设置之前，需要解释一个概念，在blog根目录里的_config.yml文件称为 站点配置文件。进入根目录里的themes文件夹，里面也有个_config.yml文件，这个称为 主题配置文件。关联Hexo和GitHub：1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github: 完整仓库路径.git branch: master 上述操作是为了配置部署博客时相关的信息，即 hexo d 所需要的部署位置信息，在这里是我们的仓库地址。最后安装Git部署插件，输入命令：1npm install hexo-deployer-git --save 此时需要本地检测博客状态(多用于调试)，可以使用指令，进入本地网址预览 localhost:40001hexo s 若需要推送到 GitPage，使用指令完成推送，稍等即可浏览仓库名一致的网站，此时即可在网页浏览博客。1234567891011121314151617181920hexo cleanhexo g #generatehexo d #deploy'''常用指令npm install hexo -g #安装Hexonpm update hexo -g #升级 hexo init #初始化博客hexo n "我的博客" == hexo new "我的博客" #新建文章hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令''' 更换主题(NexT)在把默认主题更改成NexT主题，在博客目录中打开命令行输入：1git clone https://github.com/iissnan/hexo-theme-next themes/next 这是将Next主题下载到blog目录的themes主题下的next文件夹中。打开站点的_config.yml配置文件，修改主题为next。注意 若出现更换主题后，网页加载出现主题缺失的问题，可以先hexo clean，再重新推送。若仍不成功，则可以重新启用默认主题，完成一次加载后，再选择新的主题，重新加载。12345# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next#theme: landscape 打开 主题配置文件 ,找到Scheme Settings,选择不同的主题格式123456789# ----------------------------------------------------------# Scheme Settings# ----------------------------------------------------------# Schemes#scheme: Muse#scheme: Mistscheme: Pisces#scheme: Gemini 页面设置先在 主题配置文件 menu设置处开启该链接图标，|| 后的图标是来自于Font Awesome ，所以你需要在Font Awesome网站上找到你需要的icon，然后把该icon的名字写在 || 对应菜单名后面，注意冒号有一个英文输入状态的空格。设置好后，在命令行里输入：123456menu: home: / || home about: /about ||user tags: /tags ||tags #categories: /categories/ || th archives: /archives/ || archive 添加新页面，如添加 tags1hexo new page "tags" 完成操作后，在新建的博文中加入相关的内容，如：1234title: 标签测试tags: - Testing （这个就是文章的标签了） - Another Tag （这个就是文章的标签了） 增加leancloud支持利用leancloud完成阅读量统计 注册leancloud，完成认证 创建新应用 在新应用设置中点击存储，创建Class，弹出的对话框中名字要写Counter，必须写Counter是因为需要和NexT主题兼容。然后ACL权限选择无限制，不然容易统计次数不正常。最后点击创建Class按钮。 点击设置，应用key。 把LeanCloud的应用ID和应用Key写到 主题配置文件 中123456# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: #输入获取的app id app_key: 参考 Sweet、汤圆儿 完成云引擎，安全插件等操作 利用leancloud完成评论系统通过同样的步骤获取评论应用的ID和Key，在 主题配置文件 修改相关设置12345678910111213# Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.orgvaline: enable: true # 是否开启 appid: # 上一步获取的 App ID appkey: # 上一步获取的 App Key notify: false # 新留言是否需要通知 https://github.com/xCss/Valine/wiki verify: false # 是否需要验证，验证比较反人类建议false关闭 placeholder: 请在此输入您的留言 # 默认留言框内的文字 avatar: mm # 默认头像 guest_info: nick,mail # 默认留言框的头部需要访问者输入的信息 pageSize: 10 # pagination size #默认单页的留言条数 如果在页面中不希望加入评论123title: 标签测试tags:comments: false 主页设置 在 站点配置文件 中 #site 可以完成个人相关设置 在 主题配置文件 中 #social 可以完成社交帐号的关联 第一篇博文1hexo n "name of blog" 记得加入标签，分类等相关的标注 Markdown公式渲染整合latex公式进入Markdown，同时保证其在hexo上正常渲染。首先Hexo的NexT主题本身支持MathJax,该插件可以帮助渲染公式。Markdown 本身并不支持 Latex，在渲染时正则匹配到两个_或*就会把下划线替换成了 $$,于是到了 MathJax 渲染公式就会发生错误。先打开MathJax支持：12345# MathJax Supportmathjax: enable: true per_page: false cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML 使用 hexo-renderer-kramed 替换 Hexo 默认的渲染器 hexo-renderer-marked:12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save 同时仍需解决语义冲突，在博客根目录下，找到 node_modules/kramed/lib/rules/inline.js 文件，在inline变量中做出如下修改：12345678910111213141516171819var inline = &#123; //escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/, escape: /^\\([`*\[\]()#$+\-.!_&gt;])/, autolink: /^&lt;([^ &gt;]+(@|:\/)[^ &gt;]+)&gt;/, url: noop, html: /^&lt;!--[\s\S]*?--&gt;|^&lt;(\w+(?!:\/|[^\w\s@]*@)\b)*?(?:"[^"]*"|'[^']*'|[^'"&gt;])*?&gt;([\s\S]*?)?&lt;\/\1&gt;|^&lt;(\w+(?!:\/|[^\w\s@]*@)\b)(?:"[^"]*"|'[^']*'|[^'"&gt;])*?&gt;/, link: /^!?\[(inside)\]\(href\)/, reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/, nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/, reffn: /^!?\[\^(inside)\]/, strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/, //em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/, br: /^ &#123;2,&#125;\n(?!\s*$)/, del: noop, text: /^[\s\S]+?(?=[\\&lt;!\[_*`$]| &#123;2,&#125;\n|$)/, math: /^\$\$\s*([\s\S]*?[^\$])\s*\$\$(?!\$)/,&#125;; 使用Latex时，可以参考Latx在线编辑。]]></content>
      <tags>
        <tag>Markdown</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm Design Foundation]]></title>
    <url>%2F2019%2F08%2F15%2FAlgorithm-Design-Foundation%2F</url>
    <content type="text"><![CDATA[Algorithm Design FoundationTwo Basic Example Model 1 Input &emsp; 任务集:$S={1, 2, 3, …, n}$, 第j项任务加工时间：$t_j\in\mathbb{N}$Output&ensp; 调度$I$,$S$的排列$i_1,i_2,…,i_n$目标函数 $I$的完成时间: $t(I)=$$\left(\sum_{k=1}^{n}(n-k+1)t_ik\right)$解决方法 $t(I^*)=min\left\{t(I)|I为S的排列\right\}$ 贪心算法(Greedy) 加工时间短的优先 Model 2 Input &emsp; 项目数(n)，钱数(m)，效益函数($f_i(x),i=1,2,3,…,n$)Output&ensp; $x=1,2,3,…,m(每个项目投入的金额)$解决方法 $n维向量,x_i为投资i的金额$目标函数 $max\sum_{i=1}^{n}f_i(x_i)$ &ensp; $s.t. \sum_{i=1}^{n}x_i=m,x_i\in\mathbb{N}$ 穷举法:效率(等效法): &emsp;$1….1(x_1个)01…1(x_2个)0….01…1(x_n个)$，因为$\sum x_i=m$,一共有m个1；n个项目，一共n-1个0。所以序列个数为$\binom{m}{m+n-1}=\frac{(m+n-1)!}{m!(n-1)!}=\Omega((1+\varepsilon)^{m+n-1})$ Efficiency Calculation以排序算法为例 排序方法 时间复杂度(最坏) 时间复杂度(平均) 时间复杂度(最好) 插入排序 $O(n^2)$ $O(n^2)$ $O(n)$ 希尔排序 $O(n^2)$ $O(n^1.3)$ $O(n)$ 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ 堆排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ 冒泡排序 $O(n^2)$ $O(n^2)$ $O(n)$ 快速排序 $O(n^2)$ $O(nlogn)$ $O(nlogn)$ 归并排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ $2^{0}\quad 2^{1} \quad 2^{2} \cdots 2^{k} \cdots 2^{x}=n$]]></content>
      <tags>
        <tag>Note</tag>
        <tag>Algorithm Analysis</tag>
      </tags>
  </entry>
</search>
