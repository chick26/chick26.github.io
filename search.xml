<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Html Function]]></title>
    <url>%2F2020%2F08%2F05%2FHtml-Function%2F</url>
    <content type="text"><![CDATA[HTML 元素 开始标签 元素内容 结束标签 \ 定义整个 HTML 文档 \&lt;/html&gt; \ 定义 HTML 文档的主体 \&lt;/body&gt; \ 第x个标题 \&lt;/h x&gt; \ 定义 HTML 文档中的一个段落 \&lt;/p&gt; \ 换行 无 \ 标记注释 无 \ 定义Html链接 \&lt;/a&gt; \ 定义Html图像 无 HTML 属性详情参考使用手册 属性 值 描述 class classname 规定元素的类名（classname） id id 规定元素的唯一 id style style_definition 规定元素的行内样式（inline style) title text 规定元素的额外信息（可在工具提示中显示） 注： 属性值应该始终被包括在引号内。双引号是最常用的，不过使用单引号也没有问题。 在某些个别的情况下，比如属性值本身就含有双引号，那么您必须使用单引号，例如：1name='Bill "HelloWorld" Gates' 文本格式化文字格式化标签 标签 描述 \ 定义粗体文本 \ 定义大号字 \ 定义着重文字 \ 定义斜体字 \ 定义小号字 \ 定义加重语气 \ 定义下标字 \ 定义上标字 \ 定义插入字 \ 定义删除字 “计算机”输出标签 标签 描述 \ 定义计算机代码 \ 定义键盘码 \ 定义计算机代码样本 \ 定义打字机代码 \ 定义变量 \ 定义预格式文本 引用、引用和术语定义 标签 描述 \ 定义缩写 \ 定义首字母缩写 \ 定义地址 \ 定义文字方向 \ 定义长的引用 \ 定义短的引用语 \ 定义引用、引证 \ 定义一个定义项目]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Html Introduction]]></title>
    <url>%2F2020%2F08%2F05%2FHtml-Learning%2F</url>
    <content type="text"><![CDATA[什么是 HTML？HTML 是用来描述网页的一种语言 HTML 指的是超文本标记语言 (Hyper Text Markup Language)HTML 不是一种编程语言，而是一种标记语言 (markup language)标记语言是一套标记标签 (markup tag)HTML 使用标记标签来描述网页 HTML 标签HTML 标记标签通常被称为 HTML 标签 (HTML tag) HTML 标签是由尖括号包围的关键词，比如 \ HTML 标签通常是成对出现的，比如 \ 和 \&lt;\b&gt; 标签对中的第一个标签是开始标签，第二个标签是结束标签开始和结束标签也被称为开放标签和闭合标签 HTML 文档 = 网页HTML 文档描述网页HTML 文档包含 HTML 标签和纯文本HTML 文档也被称为网页 代码示例123456789&lt;html&gt;&lt;body&gt;&lt;h1&gt;我的第一个标题&lt;/h1&gt;&lt;p&gt;我的第一个段落。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 例子解释\ 与 \ 之间的文本描述网页\ 与 \ 之间的文本是可见的页面内容\ 与 \ 之间的文本被显示为标题\ 与 \ 之间的文本被显示为段落]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Regression]]></title>
    <url>%2F2020%2F03%2F04%2FRegression%2F</url>
    <content type="text"><![CDATA[Regression回归，即找到一个函数(Function)，通过输入特征 x，输出一个数值(Scalar) 模型步骤 Step 1 模型假设，选择模型框架 假设： Linear Model $y=b+\sum w_ix_i$]]></content>
      <tags>
        <tag>Mechine Learning</tag>
        <tag>Regression</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaFundation]]></title>
    <url>%2F2020%2F01%2F07%2FJavaFundation%2F</url>
    <content type="text"><![CDATA[1.面向过程和面向对象面向对象： 面向对象易维护、易复用、易扩展。 面向过程： asd]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-Numpy]]></title>
    <url>%2F2019%2F11%2F04%2FPython-Numpy%2F</url>
    <content type="text"></content>
      <tags>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DataMining with KNN]]></title>
    <url>%2F2019%2F09%2F28%2FDataMining-with-KNN%2F</url>
    <content type="text"><![CDATA[K-NN算法 优点： 精度高，对异常值不敏感，无数据输入假定 缺点： 计算复杂度高 st=>start: 开始语句 in=>inputoutput: 输入值 e=>end: 结束语句 op=>operation: 执行操作 cond=>condition: 是否成立？ out=>inputoutput: 输出值 st->in->op->cond cond(yes)->out cond(no)->op out->e{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <tags>
        <tag>DataMining</tag>
        <tag>KNN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Learning Plan]]></title>
    <url>%2F2019%2F08%2F20%2FLearning-Plan%2F</url>
    <content type="text"><![CDATA[Main Line 理论基础 算法分析与设计 Mooc 概率论 微积分 Big Picture of Calculus; blibili 线性代数 Mit Linear Algebra; 网易公开课 凸优化理论 机器学习 西瓜书 机器学习，周志华; 部分公式推导,南瓜书 更详细的理论 统计学习方法; 代码实现 实战应用 机器学习实战 网络课程 吴恩达; 李宏毅 深度应用 TensorFlow 计算机视觉 斯坦福; 笔记 自然语言处理 斯坦福; 笔记]]></content>
      <tags>
        <tag>Mechine Learning</tag>
        <tag>Material</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Setting]]></title>
    <url>%2F2019%2F08%2F15%2FHexo-Setting%2F</url>
    <content type="text"><![CDATA[利用gitpage托管hexo博客 基本步骤 创建github账号，创建以用户名为为命名的仓库，如: chick26.github.io,此为固定写法 安装Git， 初始化Git，利用SSH完成推送 安装Node.js 安装 Hexo , 完成初次推送 域名绑定(无资金) 更换主题(NexT) 设置页面 增加leancloud支持 你的第一篇博文 Markdown公式渲染 初始化Git打开git Bash，设置基本配置信息12git config --global user.name "你的GitHub用户名"git config --global user.email "你的GitHub注册邮箱" 生成SSH密钥文件1ssh-keygen -t rsa -C "你的GitHub注册邮箱" 将位于 .ssh// 的 id_rsa.pub 密钥文件复制到 GitHub 设置中的SSH Key中在git Bash中输入指令以检测是否完成关联：1ssh git@github.com 如上则说明成功。这里之所以设置GitHub密钥原因是，通过非对称加密的公钥与私钥来完成加密，公钥放置在GitHub上，私钥放置在自己的电脑里。GitHub要求每次推送代码都是合法用户，所以每次推送都需要输入账号密码验证推送用户是否是合法用户，为了省去每次输入密码的步骤，采用了ssh，当你推送的时候，git就会匹配你的私钥跟GitHub上面的公钥是否是配对的，若是匹配就认为你是合法用户，则允许推送。这样可以保证每次的推送都是正确合法的。 安装Node.jsHexo基于Node.js开发。安装Node.js会包含环境变量及npm的安装，安装后，检测Node.js以及npm是否安装成功。12node -vnpm -v 安装Hexo新建一个专门保存博客资源的文件夹1cd myBlog 在文件夹中打开git Bash，利用npm安装Hexo1npm install -g hexo-cli 安装完成后，初始化博客1hexo init blog 关联与推送推送网站，也就是发布网站，让我们的网站可以被更多的人访问。在设置之前，需要解释一个概念，在blog根目录里的_config.yml文件称为 站点配置文件。进入根目录里的themes文件夹，里面也有个_config.yml文件，这个称为 主题配置文件。关联Hexo和GitHub：1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github: 完整仓库路径.git branch: master 上述操作是为了配置部署博客时相关的信息，即 hexo d 所需要的部署位置信息，在这里是我们的仓库地址。最后安装Git部署插件，输入命令：1npm install hexo-deployer-git --save 此时需要本地检测博客状态(多用于调试)，可以使用指令，进入本地网址预览 localhost:40001hexo s 若需要推送到 GitPage，使用指令完成推送，稍等即可浏览仓库名一致的网站，此时即可在网页浏览博客。1234567891011121314151617181920hexo cleanhexo g #generatehexo d #deploy'''常用指令npm install hexo -g #安装Hexonpm update hexo -g #升级 hexo init #初始化博客hexo n "我的博客" == hexo new "我的博客" #新建文章hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令''' 更换主题(NexT)在把默认主题更改成NexT主题，在博客目录中打开命令行输入：1git clone https://github.com/iissnan/hexo-theme-next themes/next 这是将Next主题下载到blog目录的themes主题下的next文件夹中。打开站点的_config.yml配置文件，修改主题为next。注意 若出现更换主题后，网页加载出现主题缺失的问题，可以先hexo clean，再重新推送。若仍不成功，则可以重新启用默认主题，完成一次加载后，再选择新的主题，重新加载。12345# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next#theme: landscape 打开 主题配置文件 ,找到Scheme Settings,选择不同的主题格式123456789# ----------------------------------------------------------# Scheme Settings# ----------------------------------------------------------# Schemes#scheme: Muse#scheme: Mistscheme: Pisces#scheme: Gemini 页面设置先在 主题配置文件 menu设置处开启该链接图标，|| 后的图标是来自于Font Awesome ，所以你需要在Font Awesome网站上找到你需要的icon，然后把该icon的名字写在 || 对应菜单名后面，注意冒号有一个英文输入状态的空格。设置好后，在命令行里输入：123456menu: home: / || home about: /about ||user tags: /tags ||tags #categories: /categories/ || th archives: /archives/ || archive 添加新页面，如添加 tags1hexo new page "tags" 完成操作后，在新建的博文中加入相关的内容，如：1234title: 标签测试tags: - Testing （这个就是文章的标签了） - Another Tag （这个就是文章的标签了） 增加leancloud支持利用leancloud完成阅读量统计 注册leancloud，完成认证 创建新应用 在新应用设置中点击存储，创建Class，弹出的对话框中名字要写Counter，必须写Counter是因为需要和NexT主题兼容。然后ACL权限选择无限制，不然容易统计次数不正常。最后点击创建Class按钮。 点击设置，应用key。 把LeanCloud的应用ID和应用Key写到 主题配置文件 中123456# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: #输入获取的app id app_key: 参考 Sweet、汤圆儿 完成云引擎，安全插件等操作 利用leancloud完成评论系统通过同样的步骤获取评论应用的ID和Key，在 主题配置文件 修改相关设置12345678910111213# Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.orgvaline: enable: true # 是否开启 appid: # 上一步获取的 App ID appkey: # 上一步获取的 App Key notify: false # 新留言是否需要通知 https://github.com/xCss/Valine/wiki verify: false # 是否需要验证，验证比较反人类建议false关闭 placeholder: 请在此输入您的留言 # 默认留言框内的文字 avatar: mm # 默认头像 guest_info: nick,mail # 默认留言框的头部需要访问者输入的信息 pageSize: 10 # pagination size #默认单页的留言条数 如果在页面中不希望加入评论123title: 标签测试tags:comments: false 主页设置 在 站点配置文件 中 #site 可以完成个人相关设置 在 主题配置文件 中 #social 可以完成社交帐号的关联 第一篇博文1hexo n "name of blog" 记得加入标签，分类等相关的标注 Markdown公式渲染整合latex公式进入Markdown，同时保证其在hexo上正常渲染。首先Hexo的NexT主题本身支持MathJax,该插件可以帮助渲染公式。Markdown 本身并不支持 Latex，在渲染时正则匹配到两个_或*就会把下划线替换成了 $$,于是到了 MathJax 渲染公式就会发生错误。先打开MathJax支持：12345# MathJax Supportmathjax: enable: true per_page: false cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML 使用 hexo-renderer-kramed 替换 Hexo 默认的渲染器 hexo-renderer-marked:12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save 同时仍需解决语义冲突，在博客根目录下，找到 node_modules/kramed/lib/rules/inline.js 文件，在inline变量中做出如下修改：12345678910111213141516171819var inline = &#123; //escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/, escape: /^\\([`*\[\]()#$+\-.!_&gt;])/, autolink: /^&lt;([^ &gt;]+(@|:\/)[^ &gt;]+)&gt;/, url: noop, html: /^&lt;!--[\s\S]*?--&gt;|^&lt;(\w+(?!:\/|[^\w\s@]*@)\b)*?(?:"[^"]*"|'[^']*'|[^'"&gt;])*?&gt;([\s\S]*?)?&lt;\/\1&gt;|^&lt;(\w+(?!:\/|[^\w\s@]*@)\b)(?:"[^"]*"|'[^']*'|[^'"&gt;])*?&gt;/, link: /^!?\[(inside)\]\(href\)/, reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/, nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/, reffn: /^!?\[\^(inside)\]/, strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/, //em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/, br: /^ &#123;2,&#125;\n(?!\s*$)/, del: noop, text: /^[\s\S]+?(?=[\\&lt;!\[_*`$]| &#123;2,&#125;\n|$)/, math: /^\$\$\s*([\s\S]*?[^\$])\s*\$\$(?!\$)/,&#125;; 使用Latex时，可以参考Latx在线编辑。]]></content>
      <tags>
        <tag>Markdown</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm Design Foundation]]></title>
    <url>%2F2019%2F08%2F15%2FAlgorithm-Design-Foundation%2F</url>
    <content type="text"><![CDATA[Algorithm Design FoundationTwo Basic Example Model 1 Input &emsp; 任务集:$S={1, 2, 3, …, n}$, 第j项任务加工时间：$t_j\in\mathbb{N}$Output&ensp; 调度$I$,$S$的排列$i_1,i_2,…,i_n$目标函数 $I$的完成时间: $t(I)=$$\left(\sum_{k=1}^{n}(n-k+1)t_ik\right)$解决方法 $t(I^*)=min\left\{t(I)|I为S的排列\right\}$ 贪心算法(Greedy) 加工时间短的优先 Model 2 Input &emsp; 项目数(n)，钱数(m)，效益函数($f_i(x),i=1,2,3,…,n$)Output&ensp; $x=1,2,3,…,m(每个项目投入的金额)$解决方法 $n维向量,x_i为投资i的金额$目标函数 $max\sum_{i=1}^{n}f_i(x_i)$ &ensp; $s.t. \sum_{i=1}^{n}x_i=m,x_i\in\mathbb{N}$ 穷举法:效率(等效法): &emsp;$1….1(x_1个)01…1(x_2个)0….01…1(x_n个)$，因为$\sum x_i=m$,一共有m个1；n个项目，一共n-1个0。所以序列个数为$\binom{m}{m+n-1}=\frac{(m+n-1)!}{m!(n-1)!}=\Omega((1+\varepsilon)^{m+n-1})$ Efficiency Calculation以排序算法为例 排序方法 时间复杂度(最坏) 时间复杂度(平均) 时间复杂度(最好) 插入排序 $O(n^2)$ $O(n^2)$ $O(n)$ 希尔排序 $O(n^2)$ $O(n^1.3)$ $O(n)$ 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ 堆排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ 冒泡排序 $O(n^2)$ $O(n^2)$ $O(n)$ 快速排序 $O(n^2)$ $O(nlogn)$ $O(nlogn)$ 归并排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ $2^{0}\quad 2^{1} \quad 2^{2} \cdots 2^{k} \cdots 2^{x}=n$]]></content>
      <tags>
        <tag>Note</tag>
        <tag>Algorithm Analysis</tag>
      </tags>
  </entry>
</search>
