<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[VueLearningDay02]]></title>
    <url>%2F2020%2F08%2F13%2FVueLearningDay02%2F</url>
    <content type="text"><![CDATA[模板语法插值操作Mustache数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值：1&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt; v-once能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定：1&lt;span v-once&gt;这个将不会改变: &#123;&#123; msg &#125;&#125;&lt;/span&gt; v-html能解析html语句，输出实际展示内容1&lt;span v-html="msg"&gt;&lt;/span&gt; v-pre不解析指令，直接显示元素1&lt;span v-pre &gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt; v-cloak减少需要长时间加载的元素源码暴露的风险,实际开发中函数会被解析为虚拟DOM，无太大影响：1234567891011121314151617181920212223242526&lt;head&gt;...... &lt;!-- 遇到有v-cloak属性的元素，在js指令执行前不展示 --&gt; &lt;style&gt; [v-cloak]&#123; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- v-cloak --&gt; &lt;h1 v-cloak&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;script src="./js/vue.js"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', //挂载需要管理的元素 data: &#123; //定义元素包含的数据 message: 'Hello VUE' &#125; &#125;) &lt;/script&gt; &lt;script src="./js/vue.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; v-bind 作用：动态绑定属性 缩写：: 预期：any (with argument) | Object (without argument) 参数：attrOrProp (optional) Mustache只在内容里面会使用，属性需要v-bind12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;动态绑定属性【v-bind】&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 错误做法 --&gt; &lt;!-- &lt;img src = "&#123;&#123;imgURL&#125;&#125;" alt=""&gt; --&gt; &lt;!-- 正确做法 绑定属性,给src属性赋值--&gt; &lt;img v-bind:src="imgURL" alt=""&gt; &lt;!-- 语法糖 --&gt; &lt;img :src="imgURL" alt=""&gt; &lt;/div&gt; &lt;script src='./js/vue.js'&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello Vue', imgURL: 'https://bkimg.cdn.bcebos.com/pic/43a7d933c895d143b1a710bb7df082025baf0750?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5' &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>Html</tag>
        <tag>VUE</tag>
        <tag>Day02</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueLearningDay01]]></title>
    <url>%2F2020%2F08%2F12%2FVueLearningDay01%2F</url>
    <content type="text"><![CDATA[Vue.jsVue.js安装 方法一直接CND引入 1234&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue"&gt;&lt;/script&gt; 方式二下载和引入 12&lt;!-- 开发环境 --&gt; https://vuejs.org/js/vue.js&lt;!-- 生产环境 --&gt; https://vuejs.org/js/vue.min.js 方法三后续通过webpack和CIL的使用 初识Vue实例123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--定义一个元素--&gt; &lt;div id="app"&gt;&#123;&#123;messgae&#125;&#125;&lt;/div&gt; &lt;!--本地加载Vuejs--&gt; &lt;script src="./js/vue.js"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', //挂载需要管理的元素 data: &#123; //定义对象包含的数据 message:'Hello VUE' &#125; &#125;) &lt;/script&gt; &lt;!--使用JavaScript实现--&gt; &lt;script type="text/javascript" language="javascript"&gt;&lt;/script&gt; &lt;script&gt; document.write("&lt;div&gt;Hello world&lt;/div&gt;") &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Vue框架【声明式编程-内部存在命令】 创建Vue对象 挂载需要管理的元素 [el] 定义相关的数据等信息 [data] 这些数据可以是我们直接定义出来的，比如像上面这样。 也可能是来自网络，从服务器加载的。 JS流程【命令式编程】 创建元素，设置元素属性 定义message变量 将message变量放到div中显示 列表展示12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;列表展示&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;ul&gt; &lt;li v-for="item in movies"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script src="./js/vue.js"&gt; &lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', data:&#123; message:'Movie', movies:['SuperMan','SpiderMan','BatMan','IronMan'] &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; v-for指令，响应式完成 计数器123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;计数器&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;h2&gt;当前计数: &#123;&#123;counter&#125;&#125;&lt;/h2&gt; &lt;!-- &lt;button v-on:click="counter++"&gt;+&lt;/button&gt; --&gt; &lt;!-- &lt;button v-on:click="counter--"&gt;-&lt;/button&gt; --&gt; &lt;button v-on:click="add"&gt;+&lt;/button&gt; &lt;button v-on:click="sub"&gt;-&lt;/button&gt; &lt;/div&gt; &lt;script src='./js/vue.js'&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', data:&#123; counter: 0 &#125;, methods:&#123; add: function()&#123; this.counter++; console.log('加1') &#125;, sub: function()&#123; this.counter--; console.log('减1') &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 新的属性：methods，该属性用于在Vue对象中定义方法。 新的指令：v-on:click(@click)—语法糖, 该指令用于监听某个元素的点击事件，并且需要指定当发生点击时，执行的方法(方法通常是methods中定义的方法) Vue中的MVVM MVVM（Model-View-ViewModel）是对 MVC（Model-View-Control）和 MVP（Model-View-Presenter）的进一步改进。 『View』：视图层（UI 用户界面） 『ViewModel』：业务逻辑层（一切 js 可视为业务逻辑） 『Model』：数据层（存储数据及对数据的处理如增删改查） MVVM 将数据双向绑定（data-binding）作为核心思想，View 和 Model 之间没有联系，它们通过 ViewModel 这个桥梁进行交互。 Model 和 ViewModel 之间的交互是双向的，因此 View 的变化会自动同步到 Model，而 Model 的变化也会立即反映到 View 上显示。 当用户操作 View，ViewModel 感知到变化，然后通知 Model 发生相应改变；反之当 Model 发生改变，ViewModel 也能感知到变化，使 View 作出相应更新。。 计数器中的MVVM View依然是我们的DOM Model就是我们我们抽离出来的obj ViewModel就是我们创建的Vue对象实例MVVM工作原理 ViewModel通过Data Binding让obj中的数据实时的在DOM中显示。 ViewModel通过DOM Listener来监听DOM事件，并且通过methods中的操作，来改变obj中的数据。 Vue示例 Options el: 类型：string | HTMLElement 作用：决定之后Vue实例会管理哪一个DOM。 data: 类型：Object | Function （组件当中data必须是一个函数） 作用：Vue实例对应的数据对象。 methods: 类型：{ [key: string]: Function } 作用：定义属于Vue的一些方法，可以在其他地方调用，也可以在指令中使用。]]></content>
      <tags>
        <tag>Html</tag>
        <tag>VUE</tag>
        <tag>Day01</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Html Function]]></title>
    <url>%2F2020%2F08%2F05%2FHtml-Function%2F</url>
    <content type="text"><![CDATA[HTML 元素 开始标签 元素内容 结束标签 &#60;html&gt; 定义整个 HTML 文档 \&lt;/html&gt; &#60;body&gt; 定义 HTML 文档的主体 \&lt;/body&gt; &#60;h x&gt; 第x个标题 \&lt;/h x&gt; &#60;p&gt; 定义 HTML 文档中的一个段落 \&lt;/p&gt; &#60;br /&gt; 换行 无 &#60;!— xxx —&gt; 标记注释 无 &#60;a href=”default.htm” &gt; 定义Html链接 \&lt;/a&gt; &#60;img src=”” width=”” height=”” /&gt; 定义Html图像 无 HTML 属性详情参考使用手册 属性 值 描述 class classname 规定元素的类名（classname） id id 规定元素的唯一 id style style_definition 规定元素的行内样式（inline style) title text 规定元素的额外信息（可在工具提示中显示） 注： 属性值应该始终被包括在引号内。双引号是最常用的，不过使用单引号也没有问题。 在某些个别的情况下，比如属性值本身就含有双引号，那么您必须使用单引号，例如：1name='Bill "HelloWorld" Gates' 文本格式化文字格式化标签 标签 描述 &#60;b&gt; 定义粗体文本 &#60;big&gt; 定义大号字 &#60;em&gt; 定义着重文字 &#60;i&gt; 定义斜体字 &#60;small&gt; 定义小号字 &#60;strong&gt; 定义加重语气 &#60;sub&gt; 定义下标字 &#60;sup&gt; 定义上标字 &#60;ins&gt; 定义插入字 &#60;del&gt; 定义删除字 “计算机”输出标签 标签 描述 &#60;code&gt; 定义计算机代码 &#60;kbd&gt; 定义键盘码 &#60;samp&gt; 定义计算机代码样本 &#60;tt&gt; 定义打字机代码 &#60;var&gt; 定义变量 &#60;pre&gt; 定义预格式文本 引用、引用和术语定义 标签 描述 &#60;abbr&gt; 定义缩写 &#60;acronym&gt; 定义首字母缩写 &#60;address&gt; 定义地址 &#60;bdo&gt; 定义文字方向 &#60;blockquote&gt; 定义长的引用 &#60;q&gt; 定义短的引用语 &#60;cite&gt; 定义引用、引证 &#60;dfn&gt; 定义一个定义项目 HTML5 语义元素 标签 描述 header 定义文档或节的页眉 nav 定义导航链接的容器 section 定义文档中的节 article 定义独立的自包含文章 aside 定义内容之外的内容（比如侧栏) footer 定义文档或节的页脚 details 定义额外的细节 summary 定义 details 元素的标题]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Html Introduction]]></title>
    <url>%2F2020%2F08%2F05%2FHtml-Learning%2F</url>
    <content type="text"><![CDATA[什么是 HTML？HTML 是用来描述网页的一种语言 HTML 指的是超文本标记语言 (Hyper Text Markup Language)HTML 不是一种编程语言，而是一种标记语言 (markup language)标记语言是一套标记标签 (markup tag)HTML 使用标记标签来描述网页 HTML 标签HTML 标记标签通常被称为 HTML 标签 (HTML tag) HTML 标签是由尖括号包围的关键词，比如 \ HTML 标签通常是成对出现的，比如 \ 和 \&lt;\b&gt; 标签对中的第一个标签是开始标签，第二个标签是结束标签开始和结束标签也被称为开放标签和闭合标签 HTML 文档 = 网页HTML 文档描述网页HTML 文档包含 HTML 标签和纯文本HTML 文档也被称为网页 代码示例123456789&lt;html&gt;&lt;body&gt;&lt;h1&gt;我的第一个标题&lt;/h1&gt;&lt;p&gt;我的第一个段落。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 例子解释\ 与 \ 之间的文本描述网页\ 与 \ 之间的文本是可见的页面内容\ 与 \ 之间的文本被显示为标题\ 与 \ 之间的文本被显示为段落]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Regression]]></title>
    <url>%2F2020%2F03%2F04%2FRegression%2F</url>
    <content type="text"><![CDATA[Regression回归，即找到一个函数(Function)，通过输入特征 x，输出一个数值(Scalar) 模型步骤 Step 1 模型假设，选择模型框架 假设： Linear Model $y=b+\sum w_ix_i$]]></content>
      <tags>
        <tag>Mechine Learning</tag>
        <tag>Regression</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaFundation]]></title>
    <url>%2F2020%2F01%2F07%2FJavaFundation%2F</url>
    <content type="text"><![CDATA[1.面向过程和面向对象面向对象： 面向对象易维护、易复用、易扩展。 面向过程： asd]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-Numpy]]></title>
    <url>%2F2019%2F11%2F04%2FPython-Numpy%2F</url>
    <content type="text"></content>
      <tags>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DataMining with KNN]]></title>
    <url>%2F2019%2F09%2F28%2FDataMining-with-KNN%2F</url>
    <content type="text"><![CDATA[K-NN算法 优点： 精度高，对异常值不敏感，无数据输入假定 缺点： 计算复杂度高 st=>start: 开始语句 in=>inputoutput: 输入值 e=>end: 结束语句 op=>operation: 执行操作 cond=>condition: 是否成立？ out=>inputoutput: 输出值 st->in->op->cond cond(yes)->out cond(no)->op out->e{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <tags>
        <tag>DataMining</tag>
        <tag>KNN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Learning Plan]]></title>
    <url>%2F2019%2F08%2F20%2FLearning-Plan%2F</url>
    <content type="text"><![CDATA[Main Line 理论基础 算法分析与设计 Mooc 概率论 微积分 Big Picture of Calculus; blibili 线性代数 Mit Linear Algebra; 网易公开课 凸优化理论 机器学习 西瓜书 机器学习，周志华; 部分公式推导,南瓜书 更详细的理论 统计学习方法; 代码实现 实战应用 机器学习实战 网络课程 吴恩达; 李宏毅 深度应用 TensorFlow 计算机视觉 斯坦福; 笔记 自然语言处理 斯坦福; 笔记]]></content>
      <tags>
        <tag>Mechine Learning</tag>
        <tag>Material</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Setting]]></title>
    <url>%2F2019%2F08%2F15%2FHexo-Setting%2F</url>
    <content type="text"><![CDATA[利用gitpage托管hexo博客 基本步骤 创建github账号，创建以用户名为为命名的仓库，如: chick26.github.io,此为固定写法 安装Git， 初始化Git，利用SSH完成推送 安装Node.js 安装 Hexo , 完成初次推送 域名绑定(无资金) 更换主题(NexT) 设置页面 增加leancloud支持 你的第一篇博文 Markdown公式渲染 初始化Git打开git Bash，设置基本配置信息12git config --global user.name "你的GitHub用户名"git config --global user.email "你的GitHub注册邮箱" 生成SSH密钥文件1ssh-keygen -t rsa -C "你的GitHub注册邮箱" 将位于 .ssh// 的 id_rsa.pub 密钥文件复制到 GitHub 设置中的SSH Key中在git Bash中输入指令以检测是否完成关联：1ssh git@github.com 如上则说明成功。这里之所以设置GitHub密钥原因是，通过非对称加密的公钥与私钥来完成加密，公钥放置在GitHub上，私钥放置在自己的电脑里。GitHub要求每次推送代码都是合法用户，所以每次推送都需要输入账号密码验证推送用户是否是合法用户，为了省去每次输入密码的步骤，采用了ssh，当你推送的时候，git就会匹配你的私钥跟GitHub上面的公钥是否是配对的，若是匹配就认为你是合法用户，则允许推送。这样可以保证每次的推送都是正确合法的。 安装Node.jsHexo基于Node.js开发。安装Node.js会包含环境变量及npm的安装，安装后，检测Node.js以及npm是否安装成功。12node -vnpm -v 安装Hexo新建一个专门保存博客资源的文件夹1cd myBlog 在文件夹中打开git Bash，利用npm安装Hexo1npm install -g hexo-cli 安装完成后，初始化博客1hexo init blog 关联与推送推送网站，也就是发布网站，让我们的网站可以被更多的人访问。在设置之前，需要解释一个概念，在blog根目录里的_config.yml文件称为 站点配置文件。进入根目录里的themes文件夹，里面也有个_config.yml文件，这个称为 主题配置文件。关联Hexo和GitHub：1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github: 完整仓库路径.git branch: master 上述操作是为了配置部署博客时相关的信息，即 hexo d 所需要的部署位置信息，在这里是我们的仓库地址。最后安装Git部署插件，输入命令：1npm install hexo-deployer-git --save 此时需要本地检测博客状态(多用于调试)，可以使用指令，进入本地网址预览 localhost:40001hexo s 若需要推送到 GitPage，使用指令完成推送，稍等即可浏览仓库名一致的网站，此时即可在网页浏览博客。1234567891011121314151617181920hexo cleanhexo g #generatehexo d #deploy'''常用指令npm install hexo -g #安装Hexonpm update hexo -g #升级 hexo init #初始化博客hexo n "我的博客" == hexo new "我的博客" #新建文章hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令''' 更换主题(NexT)在把默认主题更改成NexT主题，在博客目录中打开命令行输入：1git clone https://github.com/iissnan/hexo-theme-next themes/next 这是将Next主题下载到blog目录的themes主题下的next文件夹中。打开站点的_config.yml配置文件，修改主题为next。注意 若出现更换主题后，网页加载出现主题缺失的问题，可以先hexo clean，再重新推送。若仍不成功，则可以重新启用默认主题，完成一次加载后，再选择新的主题，重新加载。12345# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next#theme: landscape 打开 主题配置文件 ,找到Scheme Settings,选择不同的主题格式123456789# ----------------------------------------------------------# Scheme Settings# ----------------------------------------------------------# Schemes#scheme: Muse#scheme: Mistscheme: Pisces#scheme: Gemini 页面设置先在 主题配置文件 menu设置处开启该链接图标，|| 后的图标是来自于Font Awesome ，所以你需要在Font Awesome网站上找到你需要的icon，然后把该icon的名字写在 || 对应菜单名后面，注意冒号有一个英文输入状态的空格。设置好后，在命令行里输入：123456menu: home: / || home about: /about ||user tags: /tags ||tags #categories: /categories/ || th archives: /archives/ || archive 添加新页面，如添加 tags1hexo new page "tags" 完成操作后，在新建的博文中加入相关的内容，如：1234title: 标签测试tags: - Testing （这个就是文章的标签了） - Another Tag （这个就是文章的标签了） 增加leancloud支持利用leancloud完成阅读量统计 注册leancloud，完成认证 创建新应用 在新应用设置中点击存储，创建Class，弹出的对话框中名字要写Counter，必须写Counter是因为需要和NexT主题兼容。然后ACL权限选择无限制，不然容易统计次数不正常。最后点击创建Class按钮。 点击设置，应用key。 把LeanCloud的应用ID和应用Key写到 主题配置文件 中123456# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: #输入获取的app id app_key: 参考 Sweet、汤圆儿 完成云引擎，安全插件等操作 利用leancloud完成评论系统通过同样的步骤获取评论应用的ID和Key，在 主题配置文件 修改相关设置12345678910111213# Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.orgvaline: enable: true # 是否开启 appid: # 上一步获取的 App ID appkey: # 上一步获取的 App Key notify: false # 新留言是否需要通知 https://github.com/xCss/Valine/wiki verify: false # 是否需要验证，验证比较反人类建议false关闭 placeholder: 请在此输入您的留言 # 默认留言框内的文字 avatar: mm # 默认头像 guest_info: nick,mail # 默认留言框的头部需要访问者输入的信息 pageSize: 10 # pagination size #默认单页的留言条数 如果在页面中不希望加入评论123title: 标签测试tags:comments: false 主页设置 在 站点配置文件 中 #site 可以完成个人相关设置 在 主题配置文件 中 #social 可以完成社交帐号的关联 第一篇博文1hexo n "name of blog" 记得加入标签，分类等相关的标注 Markdown公式渲染整合latex公式进入Markdown，同时保证其在hexo上正常渲染。首先Hexo的NexT主题本身支持MathJax,该插件可以帮助渲染公式。Markdown 本身并不支持 Latex，在渲染时正则匹配到两个_或*就会把下划线替换成了 $$,于是到了 MathJax 渲染公式就会发生错误。先打开MathJax支持：12345# MathJax Supportmathjax: enable: true per_page: false cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML 使用 hexo-renderer-kramed 替换 Hexo 默认的渲染器 hexo-renderer-marked:12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save 同时仍需解决语义冲突，在博客根目录下，找到 node_modules/kramed/lib/rules/inline.js 文件，在inline变量中做出如下修改：12345678910111213141516171819var inline = &#123; //escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/, escape: /^\\([`*\[\]()#$+\-.!_&gt;])/, autolink: /^&lt;([^ &gt;]+(@|:\/)[^ &gt;]+)&gt;/, url: noop, html: /^&lt;!--[\s\S]*?--&gt;|^&lt;(\w+(?!:\/|[^\w\s@]*@)\b)*?(?:"[^"]*"|'[^']*'|[^'"&gt;])*?&gt;([\s\S]*?)?&lt;\/\1&gt;|^&lt;(\w+(?!:\/|[^\w\s@]*@)\b)(?:"[^"]*"|'[^']*'|[^'"&gt;])*?&gt;/, link: /^!?\[(inside)\]\(href\)/, reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/, nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/, reffn: /^!?\[\^(inside)\]/, strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/, //em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/, br: /^ &#123;2,&#125;\n(?!\s*$)/, del: noop, text: /^[\s\S]+?(?=[\\&lt;!\[_*`$]| &#123;2,&#125;\n|$)/, math: /^\$\$\s*([\s\S]*?[^\$])\s*\$\$(?!\$)/,&#125;; 使用Latex时，可以参考Latx在线编辑。]]></content>
      <tags>
        <tag>Markdown</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm Design Foundation]]></title>
    <url>%2F2019%2F08%2F15%2FAlgorithm-Design-Foundation%2F</url>
    <content type="text"><![CDATA[Algorithm Design FoundationTwo Basic Example Model 1 Input &emsp; 任务集:$S={1, 2, 3, …, n}$, 第j项任务加工时间：$t_j\in\mathbb{N}$Output&ensp; 调度$I$,$S$的排列$i_1,i_2,…,i_n$目标函数 $I$的完成时间: $t(I)=$$\left(\sum_{k=1}^{n}(n-k+1)t_ik\right)$解决方法 $t(I^*)=min\left\{t(I)|I为S的排列\right\}$ 贪心算法(Greedy) 加工时间短的优先 Model 2 Input &emsp; 项目数(n)，钱数(m)，效益函数($f_i(x),i=1,2,3,…,n$)Output&ensp; $x=1,2,3,…,m(每个项目投入的金额)$解决方法 $n维向量,x_i为投资i的金额$目标函数 $max\sum_{i=1}^{n}f_i(x_i)$ &ensp; $s.t. \sum_{i=1}^{n}x_i=m,x_i\in\mathbb{N}$ 穷举法:效率(等效法): &emsp;$1….1(x_1个)01…1(x_2个)0….01…1(x_n个)$，因为$\sum x_i=m$,一共有m个1；n个项目，一共n-1个0。所以序列个数为$\binom{m}{m+n-1}=\frac{(m+n-1)!}{m!(n-1)!}=\Omega((1+\varepsilon)^{m+n-1})$ Efficiency Calculation以排序算法为例 排序方法 时间复杂度(最坏) 时间复杂度(平均) 时间复杂度(最好) 插入排序 $O(n^2)$ $O(n^2)$ $O(n)$ 希尔排序 $O(n^2)$ $O(n^1.3)$ $O(n)$ 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ 堆排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ 冒泡排序 $O(n^2)$ $O(n^2)$ $O(n)$ 快速排序 $O(n^2)$ $O(nlogn)$ $O(nlogn)$ 归并排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ $2^{0}\quad 2^{1} \quad 2^{2} \cdots 2^{k} \cdots 2^{x}=n$]]></content>
      <tags>
        <tag>Note</tag>
        <tag>Algorithm Analysis</tag>
      </tags>
  </entry>
</search>
